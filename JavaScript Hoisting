## JavaScript Hoisting
Hoisting refers to the behavior where JavaScript moves the declarations of variables, functions, and classes to the top of their scope during the compilation phase. 
This can sometimes lead to surprising results, especially when using var, let, const, or function expressions.

** Hoisting applies to variable and function declarations.
** Initializations are not hoisted; they are only declarations.
** 'var' variables are hoisted with undefined, while 'let' and 'const' are hoisted but remain in the Temporal Dead Zone until initialized.

1. Variable Hoisting with var
When you use var to declare a variable, the declaration is hoisted to the top, but its value is not assigned until the code execution reaches the variable’s initialization.
This results in the variable being assigned undefined during the hoisting phase.
console.log(a); // undefined
var a = 5;

output:-
undefined 

The declaration var a is hoisted to the top, but a is initialized with undefined. 
Hence, logging results in undefined.

2. Variable Hoisting with let and const
Unlike var, let and const are also hoisted, but they remain in a Temporal Dead Zone (TDZ) from the start of the block until their declaration is encountered.
Accessing them before their declaration will throw a ReferenceError.

console.log(b); 
let b = 10;

output:-
// ReferenceError: Cannot access 'b' before initialization

The variable is hoisted, but it’s in the Temporal Dead Zone (TDZ) until the declaration line is executed.

** Temporal Dead Zone (TDZ) :--
The Temporal Dead Zone (TDZ) is a critical concept in JavaScript hoisting. 
It refers to the period between the entering of a scope (such as a function or block) and the actual initialization of a variable declared with let or const. 
During this time, any reference to the variable before its initialization will throw a ReferenceError.

## How does the TDZ Work?
* Variables declared with let and const are hoisted to the top of their scope, but they are not initialized until their declaration line is reached.
* Any attempt to access these variables before their declaration will result in an error.
* The TDZ exists only for variables declared using let and const. Variables declared with var do not have this issue, as they are hoisted and initialized to undefined.

hello();
var hello = function() {
    console.log("Hi!");
};

output:-
 // TypeError: hello is not a function

The variable hello is hoisted, but it is not initialized until the assignment line is reached since it holds a function expression. 
Thus, calling hello() before its initialization throws a TypeError.

3. Function Declaration Hoisting
Function declarations are hoisted with both their name and the function body.
This means the function can be called before its definition in the code.

greet();
function greet() {
    console.log("Hello, Mohini!");
}

output:-
 // "Hello, Mohini!"
The function declaration is hoisted, and the entire function definition is available before its position in the code.

4. Function Expression Hoisting
Function expressions are treated like variable declarations. 
The variable itself is hoisted, but the function expression is not assigned until the line of execution. 
This means calling the function before its assignment will result in an error.

hello(); 
var hello = function() {
    console.log("Hi!");
};

output:-
// TypeError: hello is not a function
The variable hello is hoisted, but since it's a function expression, it’s not initialized until the line is executed.

5. Hoisting with let and const in Functions
Variables declared with let and const inside a function are hoisted to the top of the function's scope, but they remain in the TDZ. 
This prevents access to them before they are initialized.

function test() {
    console.log(x); 
    let x = 50;
}
test();

output:-
// ReferenceError: Cannot access 'x' before initialization

The variable x is hoisted inside the function but cannot be accessed until its declaration line due to the TDZ.

6. Hoisting with Classes
Classes are hoisted, but they cannot be accessed before they are declared, resulting in a ReferenceError.
